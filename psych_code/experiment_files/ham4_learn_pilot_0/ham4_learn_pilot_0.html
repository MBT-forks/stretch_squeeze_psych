<!doctype html>
<html lang="eng">

<head>
    <title>Task</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <link rel="stylesheet" href="https://s3.amazonaws.com/miljspsych/jspsych_writer/jspsych_overload/jspsych.css?v=1682292823.928237">
    <link rel="shortcut icon" href="https://s3.amazonaws.com/miljspsych/jspsych_writer/jspsych_overload/favicon.ico?v=1682292823.928726"/>
</head>

<body style="background-color:#7F7F7F">
    <script>
        // ################### DEFINE EXPERIMENT IDENTIFIERS HERE ###################
        // Important: for automated aws setup, the name of this html file should be {experiment_name}_{experiment_number}.html
        const experiment_name = "ham4_learn_pilot";
        const experiment_number = 0;
        const aws_prefix = "lwise"; // Prefix for AWS service names on a shared account. Can be empty string "" if you don't want a prefix
        const done_qualification_type_id = "3J4VHEWGB9O7XBY8CSJMHOANX4U8VZ" //CHANGE TO PROD
        const SANDBOX = false //@@@@@@@@@@@@ CHANGE THIS @@@@@@@@@@@@@@@@@@@@@@ CHANGE THIS @@@@@@@@@@@@@@@ CHANGE THIS @@@@@@@@@@@@@@@
        const ASSIGN_QUALS_LAMBDA_API_GATEWAY_URL = "https://zdmhgtejk4.execute-api.us-east-1.amazonaws.com/prod/assign_quals"
        const MIN_WIDTH = 600
        const MIN_HEIGHT = 600
    </script>
</body>


<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/jspsych_overload/jspsych.js?v=1682292823.9282172"></script>


<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-instructions.js?v=1682292823.935534"></script>

<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-preload.js?v=1682292823.935555"></script>

<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-html-keyboard-response.js?v=1682292823.935572"></script>

<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-survey-multi-choice.js?v=1682292823.935593"></script>

<!-- <script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-browser-check.js?v=1682292823.935612"></script> -->
<script src="https://morgan-study-misc.s3.amazonaws.com/custom_mturk_jspsych_plugin_browser_check.js?v=1.001"></script>

<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-html-button-response.js?v=1682292823.935626"></script>

<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-fullscreen.js?v=1682292823.935638"></script>

<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/jspsych_overload/jspsych-psychophysics.js?v=1682292823.9356532"></script>

<script>
<!-- common_javascript/milutils/my_monitor_calibration.js -->
const jsPsychMyVirtualChinrest = (function (jspsych) {
    'use strict';

    const info = {
        name: "virtual-chinrest", parameters: {

            /** Any content here will be displayed above the card stimulus. */
            credit_card_prompt: {
                type: jspsych.ParameterType.HTML_STRING, pretty_name: "Adjustment prompt", default: `

                 <h3>We will now measure how large your monitor is.</h3>
                To help us calibrate our experiment, we would like to measure the size of your monitor. Please follow the instructions below. 
`,
            },
            credit_card_instructions: {
                type: jspsych.ParameterType.HTML_STRING, pretty_name: "Credit card instructions", default: `
<h3>Instructions:</h3>
<ul style="margin-top:1px; text-indent:4px">
    <li><b>Click and drag</b> the upper right <span style="color:red">corner</span> of the image until it is the same size as a credit card held up to
        the screen.
    </li>
    <li>You can use any card that is the same size as a credit card, like a driver's license.</li>
    <li>If you do not have access to a card, you can use a ruler: resize the card until it is 3.37 inches wide (8.56 cm).
    </li>
</ul>
`,
            },
            /** Content of the button displayed below the card stimulus. */
            credit_card_button_text: {
                type: jspsych.ParameterType.HTML_STRING,
                pretty_name: "Credit card button prompt",
                default: "Click here when the image is the same size as a credit card.",
            },
            /** How many times to measure the credit card size?  */
            credit_card_reps: {
                type: jspsych.ParameterType.INT,
                pretty_name: "Number of repetitions for credit card size measurement",
                default: 1,
            },
            /** Path to an image to be shown in the resizable item div. */
            credit_card_image_path: {
                type: jspsych.ParameterType.IMAGE, pretty_name: "Item path", default: null, preload: false,
            },
            /** The height of the item to be measured, in mm. */
            item_height_mm: {
                type: jspsych.ParameterType.FLOAT, pretty_name: "Item height (mm)", default: 53.98,
            },
            /** The width of the item to be measured, in mm. */
            item_width_mm: {
                type: jspsych.ParameterType.FLOAT, pretty_name: "Item width (mm)", default: 85.6,
            },
            /** The initial size of the card, in pixels, along the largest dimension. */
            credit_card_init_size: {
                type: jspsych.ParameterType.INT, pretty_name: "Initial Size", default: 250,
            },
            /** How many times to measure the blindspot location? If 0, blindspot will not be detected, and viewing distance and degree data not computed. */
            blindspot_reps: {
                type: jspsych.ParameterType.INT, pretty_name: "Blindspot measurement repetitions", default: 5,
            },
            /** HTML-formatted prompt to be shown on the screen, before the blindspot instructions. */
            blindspot_prompt: {
                type: jspsych.ParameterType.HTML_STRING, pretty_name: "Blindspot instructions", default: `
                       <h3>We will now measure how far away you are sitting.</h3>
        Everyone's eye has a small "blind spot", located in their peripheral vision.
        Measuring your blind spot lets us estimate how far you are sitting from your monitor, using trigonometry. This process should take no longer than a few moments. Please follow the instructions below. 
                `,
            },
            /** HTML-formatted prompt to be shown on the screen during blindspot estimates. */
            blindspot_instructions: {
                type: jspsych.ParameterType.HTML_STRING, pretty_name: "Blindspot prompt", default: `
        <h3>Instructions:</h3> 
            <ol style="margin-top:1px; text-indent:4px">
              <li>Place your left hand on the <b>space bar</b>.</li>
              <li>Then, cover your right eye with your right hand.</li>
              <li>Using your left eye, focus on the black square. Keep your focus on the black square.</li>
              <li>The <span style="color: red; font-weight: bold;">red ball</span> will seem to disappear as it moves from right to left, as it enters your blind spot. </li>
              <li>Press the space bar as soon as you see <b> the <span style="color: red;">ball</span> disappear</b> in your peripheral vision.</li>
            </ol>
            <span>You can redo these measurements by pressing the restart button.</span> <b>Press the space bar once you are ready.</b>
          `,
            },
            /** Text accompanying the remaining measurements counter. */
            blindspot_button_text: {
                type: jspsych.ParameterType.HTML_STRING,
                pretty_name: "Blindspot measurements prompt",
                default: "Remaining measurements: ",
            },
            /** HTML-formatted string for reporting the distance estimate. It can contain a span with ID 'distance-estimate', which will be replaced with the distance estimate. If "none" is given, viewing distance will not be reported to the participant. */
            viewing_distance_report: {
                type: jspsych.ParameterType.HTML_STRING,
                pretty_name: "Viewing distance report",
                default: `
                        <p>
                        Based on your responses, you are sitting about <span id='distance-estimate' style='font-weight: bold;'></span> from the screen.
                        
                        Does that seem about right?
                        </p>
                        `,
            },
            /** Label for the button that can be clicked on the viewing distance report screen to re-do the blindspot estimate(s). */
            redo_measurement_button_label: {
                type: jspsych.ParameterType.HTML_STRING,
                pretty_name: "Re-do measurement button label",
                default: "Restart",
            },
            /** Label for the button that can be clicked on the viewing distance report screen to accept the viewing distance estimate. */
            blindspot_done_prompt: {
                type: jspsych.ParameterType.HTML_STRING,
                pretty_name: "Blindspot done prompt",
                default: "Continue",
            },
        },
    };

    /**
     * **virtual-chinrest**
     *
     * jsPsych plugin for estimating physical distance from monitor and optionally resizing experiment content, based on Qisheng Li 11/2019. /// https://github.com/QishengLi/virtual_chinrest
     *
     * @author Gustavo Juantorena
     * 08/2020 // https://github.com/GEJ1
     * Contributions from Peter J. Kohler: https://github.com/pjkohler
     * @see {@link https://www.jspsych.org/plugins/jspsych-virtual-chinrest/ virtual-chinrest plugin documentation on jspsych.org}
     */
    class VirtualChinrestPlugin {
        constructor(jsPsych) {
            this.jsPsych = jsPsych;
            this.ball_size = 30;
            this.ball = null;
            this.container = null;
            this.credit_card_reps_remaining = 0;
            this.blindspot_reps_remaining = 0;
            this.ball_animation_frame_id = null;
        }

        trial(display_element, trial) {

            display_element.innerHTML = `<div id="content" style="width: 900px; margin: 0 auto;"></div>`;

            /** some additional parameter configuration */
            this.credit_card_reps_remaining = trial.credit_card_reps;
            this.blindspot_reps_remaining = trial.blindspot_reps;


            /** Assemble the trial response object */
            let trial_data = {
                credit_card_response_data: [],
                blindspot_response_data: [],
                outputs: {},
            };

            /** Credit card */
            let credit_card_aspect_ratio = trial.item_width_mm / trial.item_height_mm;
            let timestamp_start_credit_card_phase;
            const initialize_credit_card_html = (init_size_px) => {
                /** Render then set content for the credit card phase */

                const start_div_height = credit_card_aspect_ratio < 1 ? init_size_px : Math.round(init_size_px / credit_card_aspect_ratio);
                const start_div_width = credit_card_aspect_ratio < 1 ? Math.round(init_size_px * credit_card_aspect_ratio) : init_size_px;
                const adjust_size = Math.round(start_div_width * 0.1);


                //let background_color = '#7F7F7F'

                const pagesize_content = `
                        <div id="page-size">
<div style="margin-bottom:20px">
  <div style="
  text-align: left;
  background-color : #E4E4E4;
  border-color: #7F7F7F;
  border-radius: 8px;
  max-width: 100%;
  width:auto;
  display:flex;
  align-items:center;
  flex-direction:column;
  margin: 0 auto;
  padding: 2%; 
  ">
${trial.credit_card_prompt}
    </div>
    <div style="margin-bottom:20px">
                 <div style="
                      text-align: left;
                      background-color : #E4E4E4;
                      border-color: #7F7F7F;
                      border-radius: 8px;
                      max-width: 100%;
                      width:auto;
                      padding-left: 2%;
                      padding-right: 2%;
                      padding-bottom:1%;
                      display:flex;
                      align-items:center;
                      flex-direction:column;
                      margin-top:10px; 
                      ">
${trial.credit_card_instructions}
    </div>
</div>
                        <div id="item" style="
                            border: none;
                            height: ${start_div_height}px; 
                            width: ${start_div_width}px; 
                            margin: 30px auto; 
                             
                            position: relative;
                            ${trial.credit_card_image_path === null ? "" : `background-image: url(${trial.credit_card_image_path}); background-size: 100% auto; background-repeat: no-repeat;`}">
                            
                            <div 
                                id="jspsych-resize-handle" 
                                style="
                                    cursor: nesw-resize; 
                                    width: ${adjust_size}px; 
                                    height: ${adjust_size}px;
                                    border: 5px solid red; 
                                    border-radius:1px; 
                                    border-left: 0;
                                    border-bottom: 0;
                                    position: absolute;
                                    top: 0;
                                    right: 0;"
                                    >
                            </div>
                          </div>
                          
                        
                        <div style="
                        margin: 10px auto;
                         max-width: 50%; 
                         border-width: 2px; 
                         border-color: black; 
                         border-radius: 8px; ">
                        
     <div style="display: inline-block; margin: 0 auto; padding: 4px; border-radius: 8px;">
        <div style="padding:2px; margin: 1px auto; visibility: ${trial.credit_card_reps > 1 ? 'visible' : 'hidden'}">
            ${trial.blindspot_button_text}
            <span id="creditcardrepcount" style="color: black"> ${this.credit_card_reps_remaining} </span>
        </div>
        <button id="end_resize_phase" class="jspsych-btn" style="margin: 5px auto;"> ${trial.credit_card_button_text}</button>
    </div>
                         
                        </div>
                        </div>
`;

                display_element.querySelector("#content").innerHTML = pagesize_content;

                // Event listeners for mouse-based resize
                let dragging = false;
                let origin_x, origin_y;
                let item_width_cur_px, item_height_cur_px;
                const scale_div = display_element.querySelector("#item");

                function mouseupevent() {
                    dragging = false;
                }

                document.addEventListener("mouseup", mouseupevent);

                function mousedownevent(e) {
                    e.preventDefault();
                    dragging = true;
                    origin_x = e.pageX;
                    origin_y = e.pageY;
                    item_width_cur_px = parseInt(scale_div.style.width);
                    item_height_cur_px = parseInt(scale_div.style.height);
                }

                display_element
                    .querySelector("#jspsych-resize-handle")
                    .addEventListener("mousedown", mousedownevent);

                function resizeevent(e) {
                    if (dragging) {
                        let dx = e.pageX - origin_x;
                        //let dy = e.pageY - origin_y;

                        let minsize_px = 50;
                        let new_width = item_width_cur_px + dx * 2
                        new_width = Math.max(minsize_px, new_width) // Safety
                        let new_height = new_width / credit_card_aspect_ratio

                        scale_div.style.width = Math.round(new_width) + "px";
                        scale_div.style.height = Math.round(new_height) + "px";
                    }
                }

                display_element.addEventListener("mousemove", resizeevent);
                display_element
                    .querySelector("#end_resize_phase")
                    .addEventListener("click", submitCreditCardMeasurement);

                timestamp_start_credit_card_phase = performance.now()
            }

            function startCreditCardPhase() {

                // Increment the data counter
                let nprevious_reps = trial_data['credit_card_response_data'].length;
                let increment_new = true;
                if (nprevious_reps > 0) {
                    if (trial_data['credit_card_response_data'][nprevious_reps - 1].length === 0) {
                        increment_new = false;
                    }
                }
                if (increment_new) {
                    trial_data['credit_card_response_data'].push([]);
                }

                initialize_credit_card_html(trial.credit_card_init_size);
            }

            const submitCreditCardMeasurement = () => {
                // add item width info to data
                const item_width_px = document.querySelector("#item").getBoundingClientRect().width;
                const reaction_time_msec = performance.now() - timestamp_start_credit_card_phase
                const credit_card_trial_outcome = {
                    'reported_item_width_px': item_width_px,
                    'reaction_time_msec': reaction_time_msec,
                    'rel_timestamp_credit_card_phase_start': timestamp_start_credit_card_phase,
                    'initial_size_px': trial.credit_card_init_size,
                    'item_width_mm': trial.item_width_mm,
                    'item_height_mm': trial.item_height_mm, //card dimension: 85.60 × 53.98 mm (3.370 × 2.125 in)
                }
                let i = trial_data['credit_card_response_data'].length - 1;
                trial_data['credit_card_response_data'][i].push(credit_card_trial_outcome)

                this.credit_card_reps_remaining--
                if (this.credit_card_reps_remaining > 0) {
                    // Reinitialize the credit card size measurement
                    initialize_credit_card_html(trial.credit_card_init_size);
                } else {
                    finishCreditCardPhase();
                }
            }

            const finishCreditCardPhase = () => {
                // Finish credit card phase here
                let i_latest = trial_data['credit_card_response_data'].length - 1;
                let results = trial_data['credit_card_response_data'][i_latest];

                let sum = 0;
                let n = 0;
                for (let i_rep = 0; i_rep < results.length; i_rep++) {
                    const v = results[i_rep]['reported_item_width_px'];
                    sum += (typeof v !== 'undefined') ? v : 0
                    n += (typeof v !== 'undefined') ? 1 : 0
                }

                let average_item_width_px = sum / n;
                let pixels_per_mm = average_item_width_px / trial["item_width_mm"]; // Pixels per mm

                // Save calculated outputs
                trial_data['outputs']['pixels_per_mm'] = pixels_per_mm;
                trial_data['outputs']['average_reported_item_width_px'] = average_item_width_px;
                _store_jspsych_cookie(trial_data);

                // Check what to do next
                if (trial.blindspot_reps > 0) {
                    // Proceed to blind spot phase
                    generateBlindspotPhaseContent();
                    beginBlindSpotPhase()
                } else {
                    // End the entire trial here
                    endTrial();
                }
            }

            /** Create content for second screen, blind spot */
                // Add the blindspot content to the page
            const generateBlindspotPhaseContent = () => {
                    console.log('Initializing blindspot phase')

                    let blindspot_content = `
                <div id="blind-spot">
    <div style="margin-bottom:20px">
        <div style="
                      text-align: left;
                      background-color : #E4E4E4;
                      border-color: #7F7F7F;
                      border-radius: 8px;
                      max-width: 100%;
                      width:auto;
                      padding-left: 2%;
                        padding-right: 2%;
                        padding-bottom:2%;
                      display:flex;
                      align-items:center;
                      flex-direction:column;
                      margin: 0 auto;
                      ">
            ${trial.blindspot_prompt}
        </div>
          <div style="
  text-align: left;
  background-color : #E4E4E4;
  border-color: #7F7F7F;
  border-radius: 8px;
  max-width: 100%;
  width:auto;
  display:flex;
  align-items:center;
  flex-direction:column;
  margin: 0 auto;
  padding: 2%; 
  ">

        ${trial.blindspot_instructions}
                    </div>
    </div>
    <div id="svgDiv" style="height:100px; position:relative;"></div>
    <div style="display: inline-block; margin: 0 auto; padding: 4px; border-radius: 8px;">
        <div style="padding:2px; margin: 1px auto">
            ${trial.blindspot_button_text}
            <span id="blindspot_rep_counter" style="color: black"> ${trial.blindspot_reps} </span>
        </div>
        <button class="jspsych-btn" id="restart_blindspot_button">${trial.redo_measurement_button_label}</button>
    </div>
</div>
`;

                    display_element
                        .querySelector("#content").innerHTML = blindspot_content;

                    display_element
                        .querySelector("#restart_blindspot_button")
                        .addEventListener("click", function () {
                            console.log('User hit restart button');
                            beginBlindSpotPhase();

                        });
                    this.container = display_element.querySelector("#svgDiv");

                    drawBallAndSquare();
                };

            const drawBallAndSquare = () => {
                this.container.innerHTML = `
                        <div id="virtual-chinrest-circle" style="position: absolute; background-color: #f00; width: ${this.ball_size}px; height: ${this.ball_size}px; border-radius:${this.ball_size}px;"></div>
                        <div id="virtual-chinrest-square" style="position: absolute; background-color: #000; width: ${this.ball_size}px; height: ${this.ball_size}px;"></div>
                        `;
                const ball = this.container.querySelector("#virtual-chinrest-circle");
                const square = this.container.querySelector("#virtual-chinrest-square");
                const rectX = this.container.getBoundingClientRect().width - this.ball_size;
                const ballX = rectX * 0.85; // define where the ball is

                // Vertically center the ball and square
                const bounding_rect = (this.container.getBoundingClientRect());
                const topY = bounding_rect.height / 2 - this.ball_size / 2;

                ball.style.left = `${ballX}px`;
                square.style.left = `${rectX}px`;
                ball.style.top = `${topY}px`;
                square.style.top = `${topY}px`;

                this.ball = ball;
                this.square = square;
            };

            const beginBlindSpotPhase = () => {

                // Reset animatinos and event listeners
                this.jsPsych.pluginAPI.cancelAllKeyboardResponses();
                cancelAnimationFrame(this.ball_animation_frame_id);

                // Increment the data counter
                let nprevious_reps = trial_data['blindspot_response_data'].length;
                let increment_new = true;
                if (nprevious_reps > 0) {
                    if (trial_data['blindspot_response_data'][nprevious_reps - 1].length === 0) {
                        increment_new = false;
                    }
                }
                if (increment_new) {
                    trial_data['blindspot_response_data'].push([]);
                }

                // Reset the number of repetitions
                this.blindspot_reps_remaining = trial.blindspot_reps;
                document.querySelector("#blindspot_rep_counter").textContent = Math.max(this.blindspot_reps_remaining, 0).toString();

                // Draw the ball and fixation square
                resetAndWaitForBallStart();
            }

            const resetAndWaitForBallStart = () => {
                const rectX = this.container.getBoundingClientRect().width - this.ball_size;
                const ball_initialX = rectX * 0.85; // Reset the initial position of the ball
                this.ball.style.left = `${ball_initialX}px`;

                // Wait for a spacebar keypress to begin the ball trial
                this.jsPsych.pluginAPI.cancelAllKeyboardResponses();
                this.jsPsych.pluginAPI.getKeyboardResponse({
                    callback_function: startBall,
                    valid_responses: [" "],
                    rt_method: "performance",
                    allow_held_key: false,
                    persist: false,
                });
            };

            let timestamp_ball_start;
            let last_timestamp_frame;
            let get_ball_pixels_per_second = function () {
                return Math.max(window.screen.width / 16, 50);
            }
            let ball_pixels_per_second;
            let monitor_width_px;
            let monitor_height_px;
            let rel_timestamp_ball_start;

            const startBall = () => {
                monitor_width_px = window.screen.width;
                monitor_height_px = window.screen.height;
                ball_pixels_per_second = get_ball_pixels_per_second();
                rel_timestamp_ball_start = performance.now();
                this.jsPsych.pluginAPI.getKeyboardResponse({
                    callback_function: submitBallPosition,
                    valid_responses: [" "],
                    rt_method: "performance",
                    allow_held_key: false,
                    persist: false,
                });
                timestamp_ball_start = performance.now();
                last_timestamp_frame = timestamp_ball_start;
                ball_pixels_per_second = get_ball_pixels_per_second();
                this.ball_animation_frame_id = requestAnimationFrame(animateBall);
            };

            const animateBall = (timestamp_frame) => {
                let dx_default = -2;
                let telapsed_msec = timestamp_frame - last_timestamp_frame
                let dx = -(telapsed_msec / 1000 * ball_pixels_per_second) || dx_default
                const x = parseInt(this.ball.style.left);
                this.ball.style.left = `${x + dx}px`;

                last_timestamp_frame = timestamp_frame
                this.ball_animation_frame_id = requestAnimationFrame(animateBall);
            };

            const submitBallPosition = () => {
                console.log("ball submitted")
                let rel_timestamp_submit = performance.now();

                cancelAnimationFrame(this.ball_animation_frame_id);

                let ball_position = accurateRound(getElementCenter(this.ball).x, 2)
                let square_position = accurateRound(getElementCenter(this.square).x, 2);

                let blindspot_trial_outcome = {
                    'ball_position_px': ball_position,
                    'square_position_px': square_position,
                    'ball_speed_px_per_sec': ball_pixels_per_second,
                    'monitor_width_px': monitor_width_px,
                    'monitor_height_px': monitor_height_px,
                    'rel_timestamp_ball_start': rel_timestamp_ball_start,
                    'reaction_time_msec': rel_timestamp_submit - timestamp_ball_start,
                }

                let i_cur_instance = trial_data['blindspot_response_data'].length - 1;
                trial_data["blindspot_response_data"][i_cur_instance].push(blindspot_trial_outcome);

                // Decrement counter
                this.blindspot_reps_remaining--;
                document.querySelector("#blindspot_rep_counter").textContent = Math.max(this.blindspot_reps_remaining, 0).toString();

                // Finish blind spot phase or perform another trial
                if (this.blindspot_reps_remaining <= 0) {
                    // Add continue button
                    finishBlindSpotPhase();
                } else {
                    resetAndWaitForBallStart();
                }
            };


            const finishBlindSpotPhase = () => {
                const angle = 13.5;
                const blindspot_response_data = trial_data['blindspot_response_data']
                let i_latest_instance = trial_data['blindspot_response_data'].length - 1;
                let ball_position_data = blindspot_response_data[i_latest_instance] // Array of each instance of the blind spot experiment. Will be length=1 if user does not elect to repeat the blind spot phase

                const nreps_collected = ball_position_data.length;
                let sum = 0;
                let n = 0;
                for (let i_rep = 0; i_rep < nreps_collected; i_rep++) {
                    let reported_ball_x = ball_position_data[i_rep]['ball_position_px']
                    let square_x = ball_position_data[i_rep]['square_position_px']
                    let dist = square_x - reported_ball_x
                    sum += dist
                    n += 1
                }

                let average_ball_to_square_distance_pixels = accurateRound(sum / n, 2);

                // Calculate viewing distance in mm
                const viewing_distance_pixels = average_ball_to_square_distance_pixels / Math.tan(deg_to_radians(angle));
                trial_data['outputs']["viewing_distance_px"] = accurateRound(viewing_distance_pixels, 2);

                if (trial.viewing_distance_report === "none") {
                    endTrial();
                } else {
                    showReport();
                }
            };

            function accurateRound(value, decimals) {
                return Number(Math.round(Number(value + "e" + decimals)) + "e-" + decimals);
            }

            function getElementCenter(el) {
                const box = el.getBoundingClientRect();
                return {
                    x: box.left + box.width / 2,
                    y: box.top + box.height / 2,
                };
            }

            const deg_to_radians = (degrees) => {
                return (degrees * Math.PI) / 180;
            };


            /** Create content for final report screen */
            const showReport = () => {
                let viewing_distance_px = trial_data['outputs']["viewing_distance_px"];
                let pixels_per_mm = trial_data['outputs']["pixels_per_mm"];

                let skip_report = false;
                if (isNaN(parseFloat(pixels_per_mm)) === true) {
                    skip_report = true;
                }
                if (isNaN(parseFloat(viewing_distance_px)) === true) {
                    skip_report = true;
                }

                if (skip_report === true) {
                    endTrial();
                } else {
                    let report_content = `
                            <div id="distance-report"  style="
                                background-color:#E4E4E4;
                                text-align: left; 
                                border-color: #7F7F7F; 
                                border-radius: 8px; 
                                max-width: 70%; 
                                width:auto; 
                                padding-left: 2%; 
                                padding-right: 2%; 
                                padding-top: 2%; 
                                padding-bottom: 2%;
                              display:flex;
                              align-items:center;
                              flex-direction:column;
                              margin: 0 auto;
                              ">
                              <div id="info-h">
                                ${trial.viewing_distance_report}
                              </div>
                              <button id="proceed" class="jspsych-btn">${trial.blindspot_done_prompt}</button>
                              <button id="redo_blindspot" class="jspsych-btn">${trial.redo_measurement_button_label}</button>
                            </div>`;

                    // Display data
                    display_element.innerHTML = `<div id="content" style="width: 900px; margin: 0 auto;"></div>`;
                    display_element.querySelector("#content").innerHTML = report_content;
                    let viewing_distance_mm = accurateRound(viewing_distance_px / pixels_per_mm, 2);
                    display_element.querySelector("#distance-estimate").innerHTML = `${Math.round(viewing_distance_mm / 10)} cm (${Math.round(viewing_distance_mm * 0.0393701)} inches)`;
                    display_element
                        .querySelector("#redo_blindspot")
                        .addEventListener("click", initiate_trial);
                    display_element.querySelector("#proceed").addEventListener("click", endTrial);
                }
            }

            const endTrial = () => {
                // finish trial
                trial_data.rt = Math.round(performance.now() - overall_start_time);
                // remove lingering event listeners, just in case
                this.jsPsych.pluginAPI.cancelAllKeyboardResponses();

                // Clear the display
                display_element.innerHTML = "";

                // Finish the trial
                this.jsPsych.finishTrial(trial_data);
            };

            function initiate_trial() {
                if (trial.credit_card_reps > 0) {
                    startCreditCardPhase()
                } else {
                    // Skip the credit card phase
                    generateBlindspotPhaseContent();
                    beginBlindSpotPhase();
                }
            }

            // Run trial
            const overall_start_time = performance.now();
            initiate_trial();
        }
    }

    VirtualChinrestPlugin.info = info;
    return VirtualChinrestPlugin;

})(jsPsychModule);

function _store_jspsych_cookie(trial_data) {
    CookieUtils.setCookie('jspsych-my-virtual-chinrest', JSON.stringify(trial_data), 7,)
}

///// Function for getting viewing distance and monitor size
function get_monitor_calibration_node(
    ncredit_card_reps,
    nblindspot_reps,
    credit_card_prompt,
    blindspot_prompt,
) {

    // Attaches 'pixels_per_mm' and 'viewing_distance_mm' to output_data_pointer once the node is completed by the user.

    ncredit_card_reps = typeof ncredit_card_reps === 'number' ? ncredit_card_reps : 1;
    nblindspot_reps = typeof nblindspot_reps === 'number' ? nblindspot_reps : 5;

    let monitor_calibration_node = {
        type: jsPsychMyVirtualChinrest,
        credit_card_reps: ncredit_card_reps,
        blindspot_reps: nblindspot_reps,
        credit_card_image_path: 'https://miljspsych.s3.amazonaws.com/resources/assets/images/card.png',
        blindspot_prompt: blindspot_prompt,
        credit_card_prompt: credit_card_prompt,
        credit_card_init_size: function () {
            return 400;

            let initial_credit_card_size_pixels = 400; // Default
            let loaded_cookie = CookieUtils.getCookie('jspsych-my-virtual-chinrest')
            if (loaded_cookie.length > 0) {
                loaded_cookie = JSON.parse(loaded_cookie)
                console.log('Loaded cookie:', loaded_cookie)
                let final_item_width_px = loaded_cookie['outputs']['average_reported_item_width_px']
                if (typeof final_item_width_px === 'number') {
                    initial_credit_card_size_pixels = Math.min(1000, Math.max(40, final_item_width_px))
                }
            }
            return initial_credit_card_size_pixels
        },
        on_finish: function (data) {
            console.log('Monitor calibration done. Result:', data)
            _store_jspsych_cookie(data)
        }
    };

    return monitor_calibration_node
}

</script>

<script>
<!-- common_javascript/milutils/session_nodes.js -->
function get_browser_check_node(){
    let return_message = '<p>We apologize for the inconvenience. Please press the "Return" button or close the tab/window to exit.</p>'
    return {
        timeline: [
            {
                type: jsPsychBrowserCheck,
                inclusion_function: (data) => {
                    // console.log(data)
                    return data.mobile === false
                },
                exclusion_message: (data) => {
                    if (data.mobile) {
                        return '<p>You must use a desktop/laptop computer to participate in this experiment.</p>' + return_message;
                    }
                },
            },
            {
                type: jsPsychBrowserCheck,
                inclusion_function: (data) => {
                    const os = data.os.toLowerCase();
                    return os.includes("windows") || os.includes("mac") || os.includes("linux") || os.includes("chrome");
                },
                exclusion_message: (data) => {
                    return `<p>Your operating system is not supported for this experiment. Please use a device with Windows, Mac, Linux, or Chrome OS.</p>` + return_message;
                },
            },
            {
                type: jsPsychBrowserCheck,
                minimum_width: MIN_WIDTH,
                minimum_height: MIN_HEIGHT,
                exclusion_message: (data) => {
                    return `<p>Your browser does not meet the technical requirements for this experiment. Please use a device with a larger screen.</p>` + return_message;
                }
            },
        ],
    };
}

function get_preload_node(image_urls){
    return {
        type: jsPsychPreload,
        auto_preload: true,
        show_progress_bar: true,
        message: 'Loading experiment...',
        images: image_urls,
        on_finish: function () {
            console.log('Done preloading.')
            jsPsych.setProgressBar(0.002);
        }
    }
}

function get_instructions_node(instructions_html_pages){


    function wrap_instructions_html(
        instructions_string_html,
    ) {

        let div = document.createElement("div");
        div.style['width'] = "auto";
        //div.style['maxWidth'] = "80%";
        div.style['margin'] = '0 auto'
        //div.style['padding'] = '10px'
        div.style['display'] = 'flex';
        div.style['align-items'] = 'center';
        div.style['flex-direction'] = 'column';
        div.style['font-size'] = '14px';
        //div.style['z-index'] = '-1';
        //div.style['font-family'] = '\'Helvetica Neue\', serif';
        div.style['text-align'] = 'left';
        div.style['color'] = '#4B4B4B';
        div.style['background-color'] = '#E4E4E4';
        div.style['border-radius'] = '8px';
        div.style['border-color'] = '#7F7F7F';
        div.style['border-style'] = 'solid';
        div.style['padding-right'] = '2%';
        div.style['padding-left'] = '2%';
        div.style['padding-bottom'] = '2%';

        let span = document.createElement('span');
        span.innerHTML = instructions_string_html;
        div.appendChild(span);
        return div.outerHTML;
    }

    let trial_seq = [];
    for (let i_page = 0; i_page < instructions_html_pages.length; i_page++) {
        let html_cur = wrap_instructions_html(
            instructions_html_pages[i_page],
        );

        let button_text;
        if (i_page < instructions_html_pages.length - 1) {
            button_text = `Next (${i_page + 1}/${instructions_html_pages.length})`;
        }
        else{
            button_text = 'Continue';
        }
        let cur_trial = {
                type: jsPsychHtmlButtonResponse,
                stimulus: html_cur,
                choices: function () {
                    if (jsPsych.turk.turkInfo().previewMode === true)
                        return ['In preview mode. Accept HIT to continue.']
                    else
                        return [button_text]
                },
            }
        trial_seq.push(cur_trial);
    }

    let instructions_timeline = {
        timeline: trial_seq,
        loop_function: function (data) {
            if (jsPsych.turk.turkInfo().previewMode === true) {
                return true;
            } else {
                return false;
            }
        }
    }

    return instructions_timeline;

}
</script>

<script>
<!-- common_javascript/milutils/turk.js -->
function get_turk_submission_node(trialset_id) {  //(get_submission_data_function) {
    // The get_session_data_function should return a JSON object of the data you'd wish to submit to Turk.
    return {
        type: jsPsychHtmlButtonResponse,
        stimulus: '<h1>Click below to submit your work.</h1>',
        choices: ['Submit'],
        trial_duration: 10000, // Wait 5 seconds before autosubmitting
        on_finish: function () {
            const turkInfo = jsPsych.turk.turkInfo();
            let data = jsPsych.data.get().json() //get_submission_data_function()
            let datastring = JSON.stringify(data);
            // console.log(datastring)
            let dataobject = {
                'datastring': datastring,
                'workerId': turkInfo.workerId,
                'assignmentId': turkInfo.assignmentId,
                'trialset_id': trialset_id,
                'bonus_usd': MTS_TASK_GLOBALS.BONUS_USD_EARNED,
                'turkInfo': turkInfo,
            }
            jsPsych.turk.submitToTurk(dataobject);
            if (turkInfo.outsideTurk === true) {
                console.log(data)
                jsPsych.data.displayData('JSON');
            }
        },
    };
}
</script>

<script>
<!-- common_javascript/milutils/consenter_trial.js -->
function get_dicarlo_consenter_screen() {

    let consenter_text = `
<div style="text-align:left; background-color:white; margin:1%; padding:2%; border-radius:8px; border-color:black; border-width:2px;">
<h1 style="text-align:center">Welcome!</h1>    
This is a scientific study being conducted by researchers at MIT to help understand the visual system. It will involve viewing images and making responses. 
<ul>
<li>There are neither risks nor benefits associated with performing this study.</li>
<li>If you feel uncomfortable at any point during the study, you may leave at any time with no penalty.</li>
<li>You will remain anonymous. We may ask for nonidentifying demographic information, such as your gender identity and approximate age, to help us understand how our results relate to the population at large.</li>
<li>The information you provide will only be available to MIT and collaborating research institutions. Your data will be retained throughout the lifecycle of the research project and secured through personnel authorized by MIT information services. </li>

</ul>
 
Clicking on the <b>'Accept'</b> button below indicates that you are at least 18 years of age, and that you agree to complete this study voluntarily.
</div>
`

    let consenter_node = {
        timeline: [{
            type: jsPsychHtmlButtonResponse,
            stimulus: consenter_text,
            choices: ['Accept'],
        }],
    };
    return consenter_node;
}
</script>

<script>
<!-- common_javascript/milutils/cookie_utils.js -->
class CookieUtils {

    static setCookie(cname, cvalue, exdays) {
        const d = new Date();
        cvalue = encodeURIComponent(cvalue);
        d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
        let expires = "expires=" + d.toUTCString();
        let cookie_set = cname + "=" + cvalue
        let suffix = 'SameSite=None; Secure'
        document.cookie = cookie_set + ";" + expires + ";path=/" + ";" + suffix;
    }

    static getCookie(cname) {
        let name = cname + "=";
        let decodedCookie = decodeURIComponent(document.cookie);
        let ca = decodedCookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) === 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    }
}
</script>

<script>
<!-- common_javascript/milutils/action_listeners.js -->
function get_mouse_listener(
    get_active_regions_function,
    on_valid_response_function,
) {
    /*
    get_active_regions_function: Returns an array of Objects, each of which defines a different active region. Each active region is an object with the following properties:
        - x. A callable which returns the x-centroid of the active region, in coordinates of the target node to which the listener belongs.
        - y. A callable which returns the y-centroid of the active region.
        - r. A callable which returns the radius of the circle.
    on_valid_response_function: A function that is called when a valid response is made. The function is called with the following arguments:
        - data:
            {
                responseX: int,
                responseY: int,
                choices_made: [bool, bool, ...],
                rel_timestamp_response:int
            }
     */

    function check_if_inside_circle(x, y, xc, yc, r) {
        var dxs = Math.pow(x - xc, 2);
        var dys = Math.pow(y - yc, 2);
        return (dxs + dys) <= Math.pow(r, 2);
    }


    function clicked_func(event) {
        let rel_t = performance.now();
        let userX_px = event.offsetX;
        let userY_px = event.offsetY;

        //console.log('Action click:', userX_px, userY_px)
        let choice_was_selected = false;
        let data = {
            responseX: userX_px,
            responseY: userY_px,
            rel_timestamp_response: rel_t,
            choices_made:[],
            i_choice: null,
        }

        let active_regions = get_active_regions_function();
        let nactive_regions = active_regions.length;
        for (let i_region = 0; i_region < nactive_regions; i_region++) {

            let region_cur = active_regions[i_region];
            let xc = region_cur['x'];
            let yc = region_cur['y'];
            let r = region_cur['r'];

            let is_inside = check_if_inside_circle(
                userX_px,
                userY_px,
                xc,
                yc,
                r,
            );

            data['choices_made'].push(is_inside)
            if (is_inside === true) {
                // todo - handle multiple simultaneous choices
                //console.log('i_choice', i_region)
                data['i_choice'] = i_region;
            }
            choice_was_selected = choice_was_selected || is_inside;
        }

        if (choice_was_selected === true) {
            on_valid_response_function(data)
        }
    }

    return clicked_func
}


</script>

<script>
<!-- common_javascript/milutils/canvas_text.js -->
function render_wrapped_text(
    canvas_context,
    text_string,
    xleft,
    xright,
    ytop,
    ybottom,
    vertical_alignment,
    horizontal_alignment,
    max_characters_per_line,
    font,
    color,
    lineHeightFactor,
) {
    /*
    A function which renders a text string onto a canvas. This offers a few additional behaviors beyond those of the standard canvas_context.fillText() method:
     - Newline characters in the text_string are respected, and force a line break in the rendering.
     - The rendering will fill at most the "maxWidth" argument. If the text_string is too long to fit in the maxWidth, it will be wrapped to the next line.

     Arguments:
     - The "lineHeightFactor" argument controls the vertical spacing between lines. A value of 1.0 will use the default line height, while a value of 2.0 will use a line height that is twice the default.
     - You may specify a vertical_alignment argument: 'top', 'center', or 'bottom'.
     - You may specify a horizontal_alignment argument: 'left', 'center', or 'right'.
      - xleft, xright, ytop, ybottom: specifies the bounding box for the text rendering. The text is guaranteed to fit within this box.
      - If any of the above arguments are not specified, it defaults to the total canvas width/height.
      - font_size
      - font
     */

    /* Set default arguments */

    font = font || "Arial";
    text_string = text_string || "";
    xleft = xleft || 0;
    xright = xright || canvas_context.canvas.width;
    ytop = ytop || 0;
    ybottom = ybottom || canvas_context.canvas.height;
    vertical_alignment = vertical_alignment || 'centered';
    horizontal_alignment = horizontal_alignment || 'centered';
    max_characters_per_line = max_characters_per_line || 100;
    //upon_overflow = upon_overflow || 'scale';

    //
    font = font || "Arial";
    color = color || "black";
    lineHeightFactor = lineHeightFactor || 1.0;

    //
    let max_width_px = xright - xleft;

    // Estimate the font size
    let max_width_px_per_character = max_width_px / max_characters_per_line;
    let font_size_px = max_width_px_per_character * 1.5 || 12;

    font_size_px = Math.max(Math.round(font_size_px), 2);
    canvas_context.font = font_size_px.toString() + "px " + font;
    canvas_context.fillStyle = color;

    // Set the line height
    let lineHeight = canvas_context.measureText("M").width * lineHeightFactor;

    // Begin rendering process
    let cars = text_string.split("\n"); // Force line breaks if there are newline characters
    const ncars = cars.length;

    // Estimate the total height of the rendered text with the given parameters
    let total_height_px = 0;
    for (let i_car = 0; i_car < ncars; i_car++) {
        let line = "";
        let words = cars[i_car].split(" ");

        for (let n = 0; n < words.length; n++) {
            let testLine = line + words[n] + " ";
            let metrics = canvas_context.measureText(testLine);
            let testWidth = metrics.width;

            if (testWidth > max_width_px) {
                line = words[n] + " ";
                total_height_px += lineHeight;
            } else {
                line = testLine;
            }
        }
        total_height_px += lineHeight;
    }

    // Render canvas text, linewise
    let ycur;
    if (vertical_alignment === 'top') {
        // Begin rendering at the top.
        canvas_context.textBaseline = "top";
        ycur = ytop;
    } else if (vertical_alignment === 'bottom') {
        canvas_context.textBaseline = "bottom";
        // Begin rendering so the last line is at the bottom.
        ycur = ybottom - total_height_px;
    } else {
        canvas_context.textBaseline = "middle";
        ycur = (ytop + ybottom - total_height_px) / 2;
    }

    let xstart;
    if (horizontal_alignment === 'left') {
        canvas_context.textAlign = "left";
        xstart = xleft;
    } else if (horizontal_alignment === 'right') {
        canvas_context.textAlign = "right";
        xstart = xright;
    } else {
        canvas_context.textAlign = "center";
        xstart = (xleft + xright) / 2;
    }
    canvas_context.fontWeight = 'lighter'


    for (let i_car = 0; i_car < ncars; i_car++) {
        let line = "";
        let words = cars[i_car].split(" ");

        // Iterate over each word
        for (let n = 0; n < words.length; n++) {
            let testLine = line + words[n] + " ";
            let resultant_line_width = canvas_context.measureText(testLine).width;

            if (resultant_line_width > max_width_px) {
                // Fill the line as is
                canvas_context.fillText(line, xstart, ycur);
                line = words[n] + " ";
                ycur += lineHeight;
            } else {
                line = testLine;
            }
        }

        canvas_context.fillText(line, xstart, ycur);
        ycur += lineHeight;
    }
    // Draw rectangle around text draw region (for debugging)
    //canvas_context.lineWidth = 2;
    //canvas_context.strokeStyle = 'black';
    //canvas_context.rect(xleft, ytop, xright - xleft, ybottom - ytop);
    //canvas_context.stroke();
}

function renderCenteredWrappedText(context, text, x, y, max_width_px, max_characters_per_line, lineHeight, font, color) {
  font = font || "Arial";
  context.fillStyle = color || "black";
  context.textAlign = "center";
  context.textBaseline = "middle";

    // Estimate the font size
    let max_width_px_per_character = max_width_px / max_characters_per_line;
    let font_size_px = max_width_px_per_character * 1.7 || 12;

    font_size_px = Math.max(Math.round(font_size_px), 2);
    context.font = font_size_px.toString() + "px " + font;

  // Split text by words
  var words = text.split(' ');
  var line = '';
  var lines = [];

  for(var n = 0; n < words.length; n++) {
    var testLine = line + words[n] + ' ';
    var metrics = context.measureText(testLine);
    var testWidth = metrics.width;
    if (testWidth > max_width_px && n > 0) {
      lines.push(line);
      line = words[n] + ' ';
    } else {
      line = testLine;
    }
  }
  lines.push(line);

  // Calculate the starting y position
  var startingY = y - (lines.length - 1) * lineHeight / 2;

  // Draw each line
  for (var i = 0; i < lines.length; i++) {
    context.fillText(lines[i], x, startingY + i * lineHeight);
  }
}

</script>



<script>
    let MTS_TASK_GLOBALS = new class {
    constructor() {
        /*
        Get default viewing parameters (legacy choices)
        Legacy choice is that 17.5% of the smallest screen dimension corresponds to 6 degrees of visual angle.
         */

        let reference_degrees_default = 6;
        let reference_proportion_default = 0.175;
        let screen_s = Math.min(window.screen.height, window.screen.width); // Min of height and width
        let viewing_distance_pixels_default = (reference_proportion_default * screen_s / 2) / Math.tan((reference_degrees_default / 2) * Math.PI / 180)

        function infer_canvas_size_legacy() {
            // Present the canvases at 70% of the smallest screen dimension
            let [screen_height, screen_width] = [window.screen.height, window.screen.width]
            let screen_margin = 0.3;
            return Math.round(Math.min(screen_height, screen_width)) * (1 - screen_margin);
        }

        this.BACKGROUND_COLOR = '#7F7F7F';
        this.VIEWING_DISTANCE_PIXELS = viewing_distance_pixels_default;

        //this.CANVAS_HEIGHT_PIXELS = get_size()//infer_canvas_size_legacy();
        //this.CANVAS_WIDTH_PIXELS = get_size(); //infer_canvas_size_legacy();
        this.CALIBRATED = false;

        /*
        HUD parameters for tracking
         */
        this.BONUS_USD_EARNED = 0;
        this.TRIALS_COMPLETED = 0;
        this.NTRIALS = 0;

    }

    _get_size() {
        let [h, w] = [0.90 * window.innerHeight, 0.95 * window.innerWidth];
        return Math.round(Math.min(h, w))

    }

    get_canvas_height_pixels() {
        return this._get_size();
    }

    get_canvas_width_pixels() {
        return this._get_size();
    }

    calibrate_viewing_distance(viewing_distance_pixels) {
        if (typeof viewing_distance_pixels === 'number') {
            if (viewing_distance_pixels > 0) {
                this.VIEWING_DISTANCE_PIXELS = viewing_distance_pixels;
                this.CALIBRATED = true;
            }
        }
    }

    stimulus_degrees_to_pixels(degrees) {
        /*
        Convert degrees of visual angle to pixels on the screen, assuming stimulus is
        presented at normal angle.
         */

        let radians = degrees * Math.PI / 180;
        let pixels = 2 * this.VIEWING_DISTANCE_PIXELS * Math.tan(radians / 2);

        // Safety checks
        // Underflow
        let min_pixels = 0;
        let max_pixels = Math.min(this.get_canvas_height_pixels(), this.get_canvas_width_pixels())
        if (pixels < 0) {
            pixels = min_pixels;
        }
        // Overflow
        if (pixels > max_pixels) {
            pixels = max_pixels
        }

        return pixels
    }
}()


class MTS_Trial_Nodes {

    static get_timeline() {

        let fixation_node = MTS_Trial_Nodes.get_fixation_node()
        let blank_screen = MTS_Trial_Nodes.get_blank_screen_node(
            () => {
                return MTS_TASK_GLOBALS.BACKGROUND_COLOR
            },
            () => {
                return MTS_TASK_GLOBALS.get_canvas_width_pixels()
            },
            () => {
                return MTS_TASK_GLOBALS.get_canvas_height_pixels()
            },
            0,
        );
        let stimulus_choice_node = MTS_Trial_Nodes.get_nway_stimulus_choice_node();
        let feedback_node = MTS_Trial_Nodes.get_feedback_node();
        let intertrial_node = MTS_Trial_Nodes.get_intertrial_node();

        // let timeline = [
        //     fixation_node,
        //     blank_screen,
        //     stimulus_choice_node,
        //     blank_screen,
        //     feedback_node,
        //     intertrial_node,
        // ]
        let timeline = [
            stimulus_choice_node,
            blank_screen,
            feedback_node,
            intertrial_node,
        ]
        return timeline
    }

    static get_blank_screen_node(
        background_color,
        canvas_width_px,
        canvas_height_px,
        duration_msec
    ) {
        let blank_screen = {
            type: jsPsychPsychophysics,
            stimuli: [],
            background_color: background_color,
            response_type: 'key',
            response_ends_trial: true, // from the trial start (ms)
            trial_duration: duration_msec, // One frame
            canvas_width: canvas_width_px,
            canvas_height: canvas_height_px,
            canvas_offsetX: 0,
            canvas_offsetY: 0,
            clear_canvas: false, // WARNING: I SET TO FALSE ONLY FOR STATIC CASES // If true, the canvas is cleared every frame. There are not many cases where this should be false, but if you want to draw the trajectory of the mouse, for example, you need to set it false. Note that in that case, the show_end_time property can not be used. See the mouse drawing.html
            remain_canvas: false, // If true, the canvas is not cleared at the end of the trial.
            show_start_time: 0, // from the trial start (ms)
            show_end_time: undefined, // from the trial start (ms)
        }
        return blank_screen;
    }


    static get_feedback_node() {

        let get_reinforcement = function () {
            let last_trial_data = jsPsych.data.get().last(2).values()[0];
            let trial_outcome = last_trial_data['trial_outcome']
            let perf = trial_outcome['perf']

            let reinforcement = 0;

            if (perf > 0) {
                reinforcement = 1;
            } else {
                reinforcement = -1;
            }
            return reinforcement
        }

        let get_feedback_duration_msec = function () {
            let reinforcement = get_reinforcement();
            if (reinforcement > 0) {
                return jsPsych.timelineVariable('reward_duration_msec');
            } else if (reinforcement < 0) {
                return jsPsych.timelineVariable('incorrect_duration_msec');
            } else {
                return 0;
            }
        }

        let get_feedback_lockout_duration_msec = function () {
            let reinforcement = get_reinforcement();
            if (reinforcement > 0) {
                return jsPsych.timelineVariable('correct_feedback_lockout_duration_msec');
            } else if (reinforcement < 0) {
                return jsPsych.timelineVariable('incorrect_feedback_lockout_duration_msec');
            } else {
                return 0;
            }
        }

        let get_feedback_stimulus = function () {

            let positive_feedback_object;
            let negative_feedback_object;

            let feedback_correct_url = jsPsych.timelineVariable('feedback_correct_url', true);
            let feedback_incorrect_url = jsPsych.timelineVariable('feedback_incorrect_url', true);
            let get_feedback_size = function () {
                return MTS_TASK_GLOBALS.stimulus_degrees_to_pixels(jsPsych.timelineVariable('stimulus_width_degrees', true))/3;
            }

            let canvas_width = MTS_TASK_GLOBALS.get_canvas_width_pixels();
            let canvas_height = MTS_TASK_GLOBALS.get_canvas_height_pixels();

            if (feedback_correct_url !== undefined) {
                positive_feedback_object = {
                    obj_type: 'image', // means a rectangle
                    startX: 'center', // location in the canvas
                    startY: 'center',
                    file: feedback_correct_url,
                    image_width: get_feedback_size, // of the rectangle
                    //line_color: '#ffffff',
                    fill_color: '#62c63b',
                    show_start_time: 0, // from the trial start (ms)
                }
            } else {
                // Fallback
                positive_feedback_object = {
                    obj_type: 'rect', // means a rectangle
                    startX: 'center', // location in the canvas
                    startY: 'center',
                    width: get_feedback_size,
                    height: get_feedback_size,
                    //line_color: '#ffffff',
                    fill_color: '#62c63b',
                    show_start_time: 0, // from the trial start (ms)
                }
            }

            if (feedback_incorrect_url !== undefined) {
                negative_feedback_object = {
                    obj_type: 'image', // means a rectangle
                    startX: 'center', // location in the canvas
                    startY: 'center',
                    file: feedback_incorrect_url,
                    image_width: get_feedback_size,
                    //line_color: '#ffffff',
                    fill_color: '#af1111',
                    show_start_time: 0, // from the trial start (ms)
                }
            } else {
                // Fallback
                negative_feedback_object = {
                    obj_type: 'rect', // means a rectangle
                    startX: 'center', // location in the canvas
                    startY: 'center',
                    width: get_feedback_size,
                    height: get_feedback_size,
                    fill_color: '#000000',
                    show_start_time: 0 // from the trial start (ms)
                }
            }

            const neutral_feedback_object = {
                obj_type: 'rect', // means a rectangle
                startX: 'center', // location in the canvas
                startY: 'center',
                width: 0, // of the rectangle
                height: 0,
                fill_color: function () {
                    return MTS_TASK_GLOBALS.BACKGROUND_COLOR
                },
                show_start_time: 0 // from the trial start (ms)
            }

            let feedback_objects = [];

            // Original stimulus image
            let stimulus_image_url = jsPsych.timelineVariable('stimulus_image_url', true);
            let stimulus_width_px = MTS_TASK_GLOBALS.stimulus_degrees_to_pixels(jsPsych.timelineVariable('stimulus_width_degrees', true));
            let stimulus_height_px = stimulus_width_px // TODO need to implement properly for non-square images
            let stimulus_object = {
                obj_type: 'image',
                startX: 'center',
                startY: 'center', // Adjust this to leave room for feedback and text below
                file: stimulus_image_url,
                image_width: stimulus_width_px,
            };
            feedback_objects.push(stimulus_object);

            // Determine reinforcement and accordingly set feedback and text
            let reinforcement = get_reinforcement();
            let last_trial_data = jsPsych.data.get().last(2).values()[0];
            let trial_outcome = last_trial_data['trial_outcome'];
            let stimulus_name = trial_outcome['stimulus_name'];
            let choice_name = trial_outcome['choice_name'];

            let feedback_stimulus;
            let feedback_text_line1;
            let feedback_text_line2;
            let feedback_text_color;
            let feedback_text_font;
            let min_feedback_duration;
            if (reinforcement > 0) {
                // Positive feedback
                feedback_stimulus = positive_feedback_object; // Assuming positive_feedback_object is defined similarly to your original code
                //feedback_text = `Correct!\nThe answer is: ${stimulus_name}`;
                feedback_text_line1 = `Your answer: ${choice_name}`
                feedback_text_line2 = stimulus_name // `Correct answer: ${stimulus_name}`
                feedback_text_color = '#5df542'
                feedback_text_font = "bold 24px Arial"
                min_feedback_duration = jsPsych.timelineVariable('correct_feedback_lockout_duration_msec')
            } else if (reinforcement < 0) {
                // Negative feedback
                feedback_stimulus = negative_feedback_object; // Assuming negative_feedback_object is defined similarly to your original code
                //feedback_text = `Incorrect.\nThe answer is: ${stimulus_name}.\nYou answered: ${choice_name}`;
                feedback_text_line1 = `Your answer:    ${choice_name}`
                feedback_text_line2 = stimulus_name //`Correct answer: ${stimulus_name}`
                feedback_text_color = '#ff4f4f'
                feedback_text_font = "24px Arial"
                min_feedback_duration = jsPsych.timelineVariable('incorrect_feedback_lockout_duration_msec')
            }

            // let vert_gap = Math.min((canvas_height - (canvas_height/2 + stimulus_height_px/2 + get_feedback_size())) / 6, 40);
            let vert_gap = 50

            //feedback_stimulus.startY = canvas_height/2 + stimulus_height_px/2 + (get_feedback_size()*0.85)/2 + 0.5*vert_gap; // Adjust startY based on the height of the stimulus_object. CAUTION assumes stimulus_width_px = stimulus_height_px
            feedback_stimulus.startY = canvas_height/2 - stimulus_height_px/2 - get_feedback_size()/2; // Adjust startY based on the height of the stimulus_object. CAUTION assumes stimulus_width_px = stimulus_height_px
            feedback_objects.push(feedback_stimulus);

            // feedback_objects.push({
            //     obj_type: 'text',
            //     content: feedback_text_line1,
            //     startX: 'center',
            //     startY: canvas_height/3 + stimulus_height_px/2 + get_feedback_size()*0.85 + 1.5*vert_gap, // Adjust this based on feedback_stimulus position
            //     text_color: feedback_text_color,
            //     font: feedback_text_font,
            //     text_space: 20,
            // });

            feedback_objects.push({
                obj_type: 'text',
                content: feedback_text_line2,
                startX: 'center',
                startY: canvas_height/2 + stimulus_height_px/2 + vert_gap, // Adjust this based on feedback_stimulus position
                text_color: 'white',
                font: "bold 48px Arial",
                text_space: 20,
            });

            // Instruction text ("Press spacebar to continue")
            let instruction_text_object = {
                obj_type: 'text',
                content: "Press spacebar to continue",
                startX: 'center',
                startY: canvas_height/2 + stimulus_height_px/2 + 2*vert_gap, // Adjust this based on feedback_text_object position
                text_color: 'white',
                show_start_time: min_feedback_duration,
                font: "24px Arial",
                text_space: 20,
            };
            feedback_objects.push(instruction_text_object);

            return feedback_objects;
        }

        let feedback_screen = {
            type: jsPsychPsychophysics,
            stimuli: get_feedback_stimulus,
            background_color: function () {
                return MTS_TASK_GLOBALS.BACKGROUND_COLOR
            },
            canvas_width: function () {
                return MTS_TASK_GLOBALS.get_canvas_width_pixels()
            },
            canvas_height: function () {
                return MTS_TASK_GLOBALS.get_canvas_height_pixels()
            },
            response_type: 'key',
            choices: [' '],
            response_start_time: get_feedback_lockout_duration_msec,
            trial_duration: get_feedback_duration_msec,
            canvas_offsetX: 0,
            canvas_offsetY: 0,
            clear_canvas: false, // WARNING: I SET TO FALSE ONLY FOR STATIC CASES // If true, the canvas is cleared every frame. There are not many cases where this should be false, but if you want to draw the trajectory of the mouse, for example, you need to set it false. Note that in that case, the show_end_time property can not be used. See the mouse drawing.html
            remain_canvas: false, // If true, the canvas is not cleared at the end of the trial.
            on_finish: function (data) {
                let ntrials = MTS_TASK_GLOBALS.NTRIALS;
                // Increment progressbar
                let cur_progress_bar_value = jsPsych.getProgressBarCompleted();
                jsPsych.setProgressBar(cur_progress_bar_value + (1 / ntrials));
            }
        }
        return feedback_screen
    }

    static get_fixation_node() {

        let get_startX_px = function () {
            let px = MTS_TASK_GLOBALS.get_canvas_width_pixels() * 0.5 // Center
            return px
        };

        let get_startY_px = function () {
            let px = MTS_TASK_GLOBALS.get_canvas_height_pixels() * 0.5
            return px
        };

        let get_radius_px = function () {
            let px = MTS_TASK_GLOBALS.get_canvas_width_pixels() * 0.02 // Legacy choice
            return px
        }

        function get_fixation_active_region() {
            return {
                obj_type: 'circle',
                startX: get_startX_px,
                startY: get_startY_px,
                origin_center: false,
                radius: get_radius_px,
                line_color: 'white',
                fill_color: 'white',
                show_start_time: 0
            }
        }

        const fixation_cross = {
            obj_type: 'cross',
            startX: 'center',
            startY: 'center',
            line_length: function () {
                let px = MTS_TASK_GLOBALS.get_canvas_width_pixels() * 0.02
                px = Math.max(px, 10) // Legacy choice
                return px
            },
            line_color: 'black',
            show_start_time: 0
        }

        function get_active_regions() {
            return [{
                x: get_startX_px(),
                y: get_startY_px(),
                r: get_radius_px(),
            }]
        }

        let fixation_clicked_func = get_mouse_listener(
            get_active_regions,
            function (data) {
                //console.log("Fixation acquired")
                document.body.style.cursor = 'none';
                jsPsych.finishTrial(data)
            },
        )

        // Trial initiation screen
        return {
            type: jsPsychPsychophysics,
            stimuli: function () {
                return [get_fixation_active_region(), fixation_cross]
            },
            response_type: 'mouse',
            response_start_time: 0,
            response_ends_trial: false,
            mouse_down_func: fixation_clicked_func,
            background_color: function () {
                return MTS_TASK_GLOBALS.BACKGROUND_COLOR
            },
            canvas_width: function () {
                return MTS_TASK_GLOBALS.get_canvas_width_pixels();
            },
            canvas_height: function () {
                return MTS_TASK_GLOBALS.get_canvas_height_pixels();
            },
            canvas_offsetX: 0,
            canvas_offsetY: 0,
            clear_canvas: false, // WARNING: I SET TO FALSE ONLY FOR STATIC CASES // If true, the canvas is cleared every frame. There are not many cases where this should be false, but if you want to draw the trajectory of the mouse, for example, you need to set it false. Note that in that case, the show_end_time property can not be used. See the mouse drawing.html
            remain_canvas: false, // If true, the canvas is not cleared at the end of the trial.
        }
    }


    static get_nway_stimulus_choice_node() {

        let t0_choices_drawn;
        let stimulus_width_px;
        let choice_width_px_default;
        let choice_width_px
        let trial_monitor_width_px = window.screen.width;
        let trial_monitor_height_px = window.screen.height;
        let cursor_hidden;
        let choices_drawn = false;
        let stimulus_drawn = false;

        function get_stimulus_object(
            stimulus_image_url,
            image_width_px,
            stimulus_duration_msec,
            leave_stimulus_on,
        ) {

            let show_end_time;
            if (leave_stimulus_on === true) {
                show_end_time = undefined
            } else {
                show_end_time = stimulus_duration_msec
            }
            let stimulus_object = {
                obj_type: 'image',
                startX: 'center',
                startY: 'center',
                origin_center: true,
                file: stimulus_image_url,
                image_width: image_width_px,
                show_start_time: 0,
                show_end_time: null,
            };

            return stimulus_object;
        }


        function get_choice_stimuli(
            choice_image_urls,
            radius_px,
            image_width_px,
            choice_onset_msec,
        ) {
            let nchoices = choice_image_urls.length;
            let xy = get_choice_locations(nchoices, radius_px)

            let choice_objects = []
            for (let i_choice = 0; i_choice < nchoices; i_choice++) {
                let choice_i_image_url = choice_image_urls[i_choice];

                let choice_i_object = {
                    obj_type: 'image',
                    startX: xy[0][i_choice], // location in the canvas
                    startY: xy[1][i_choice],
                    origin_center: true,
                    file: choice_i_image_url,
                    image_width: image_width_px,
                    show_start_time: choice_onset_msec, // from the trial start (ms)
                    show_end_time: undefined, // from the trial start (ms)
                }

                choice_objects.push(choice_i_object)
            }

            return choice_objects
        }


        function get_choice_locations(nway, radius_px) {
            // Returns choice centroids in x and y coordinates, [x_seq, y_seq]
            // Ensures the centroids are equally spaced around a circle of r = radius
            // And that the choices are arranged in a way that is horizontally symmetric.

            let is_even = nway % 2 === 0
            let theta_0 = 0
            if (is_even === false) {
                theta_0 = Math.PI / 2; // Set the first choice to be theta = -90
            }
            else if (nway === 2) {
                theta_0 = Math.PI
            }
            // let theta_0 = 2*Math.PI*Math.random() // This version creates a random (not necessarily symmetric) rotation of the ring.

            let theta_seq = []
            for (let i = 0; i < nway; i++) {
                let theta_i = 2 * Math.PI * i / nway + theta_0;
                theta_seq.push(theta_i)
            }

            let x_seq = theta_seq.map(theta_i => radius_px * Math.cos(theta_i))
            let y_seq = theta_seq.map(theta_i => radius_px * Math.sin(theta_i))
            return [x_seq, y_seq]
        }

        function get_prompt_draw(
            query_string,
            canvas_width_px,
            canvas_height_px,
            min_y_bound,
            prompt_onset_msec,
        ) {

            let size = canvas_width_px;
            let max_text_width = size * 0.75
            let line_height_factor = 1.4;
            let font = 'Arial'
            let max_characters_per_line = 50;
            let horizontal_alignment = 'center';
            let vertical_alignment = 'bottom';


            let draw_func = function (stimulus, canvas, context, elapsedTime, sumOfStep) {
                let xleft = MTS_TASK_GLOBALS.get_canvas_width_pixels() / 2 - max_text_width / 2;
                let xright = MTS_TASK_GLOBALS.get_canvas_width_pixels() / 2 + max_text_width / 2;
                let ytop = 0;
                let ybottom = min_y_bound;
                renderCenteredWrappedText(
                    context, 
                    query_string, 
                    MTS_TASK_GLOBALS.get_canvas_width_pixels() / 2, 
                    MTS_TASK_GLOBALS.get_canvas_width_pixels() / 2, 
                    max_text_width, 
                    max_characters_per_line,
                    10, 
                    font, 
                    'white'
                )
            }

            return {
                obj_type: 'manual',
                startX: 0, // location in the canvas
                startY: 0,
                origin_center: true,
                drawFunc: draw_func,
                show_start_time: prompt_onset_msec, // from the trial start (ms)
                show_end_time: undefined // from the trial start (ms)
            }
        }


        function assemble_stimuli() {
            //console.log('Assemble stimuli called')
            // Timeline variables
            let query_string = jsPsych.timelineVariable('query_string');
            let canvas_width_px = MTS_TASK_GLOBALS.get_canvas_width_pixels();
            let canvas_height_px = MTS_TASK_GLOBALS.get_canvas_height_pixels();
            stimulus_width_px = MTS_TASK_GLOBALS.stimulus_degrees_to_pixels(jsPsych.timelineVariable('stimulus_width_degrees', true));
            choice_width_px_default = MTS_TASK_GLOBALS.stimulus_degrees_to_pixels(jsPsych.timelineVariable('choice_width_degrees_default', true));
            let stimulus_image_url = jsPsych.timelineVariable('stimulus_image_url');
            let leave_stimulus_on = jsPsych.timelineVariable('keep_stimulus_on');
            let choice_names = jsPsych.timelineVariable('choice_names')
            let choice_image_urls = jsPsych.timelineVariable('choice_image_urls');
            let stimulus_duration_msec = jsPsych.timelineVariable('stimulus_duration_msec');
            let post_stimulus_delay_msec = jsPsych.timelineVariable('post_stimulus_delay_duration_msec');

            // Get stimulus object
            let stimulus_object = get_stimulus_object(
                stimulus_image_url,
                stimulus_width_px,
                stimulus_duration_msec,
                leave_stimulus_on
            )

            let stimulus_canary_object = {
                obj_type: 'manual',
                show_start_time: 0, // from the trial start (ms)
                show_end_time: undefined, // from the trial start (ms)
                drawFunc: function (stimulus, canvas, context, elapsedTime, sumOfStep) {
                    //console.log('Stimulus canary', global_call)
                    if (stimulus_drawn === false) {
                        stimulus_width_px = stimulus_width_px;
                        trial_monitor_width_px = window.screen.width;
                        trial_monitor_height_px = window.screen.height;
                        stimulus_drawn = true;
                    }
                }
            }

            // Get choice objects
            let min_canvas_dim = Math.min(MTS_TASK_GLOBALS.get_canvas_width_pixels(), MTS_TASK_GLOBALS.get_canvas_height_pixels());
            let choice_radius_px = parseInt((min_canvas_dim - 1.05*choice_width_px_default)/2.5);
            let n_choices = choice_image_urls.length
            choice_width_px = parseInt(Math.sin(Math.PI/n_choices)*2*choice_radius_px)
            if (choice_width_px > choice_width_px_default) {
                choice_width_px = choice_width_px_default
            }
            let choice_onset_msec = post_stimulus_delay_msec + stimulus_duration_msec;
            let choice_objects = get_choice_stimuli(
                choice_image_urls,
                choice_radius_px,
                choice_width_px,
                choice_onset_msec,
            )

            // Get canary object for getting draw time of the choice stimuli
            let choice_canary_object = {
                obj_type: 'manual',
                show_start_time: choice_onset_msec, // from the trial start (ms)
                show_end_time: undefined, // from the trial start (ms)
                drawFunc: function (stimulus, canvas, context, elapsedTime, sumOfStep) {
                    if (choices_drawn === false) {
                        t0_choices_drawn = performance.now();
                        choices_drawn = true;

                    }
                }
            }

            // Get text prompt
            let xy = get_choice_locations(choice_image_urls.length, choice_radius_px)
            let min_y_bound = canvas_height_px / 2
            let prompt_object = get_prompt_draw(
                query_string,
                canvas_width_px,
                canvas_height_px,
                min_y_bound,
                choice_onset_msec,
            )

            // Assemble all objects
            let stim_array = choice_objects.concat([stimulus_object, stimulus_canary_object, choice_canary_object])
            return stim_array
        }

        function on_valid_response(data) {
            let pre_choice_lockout_delay_duration_msec = jsPsych.timelineVariable('pre_choice_lockout_delay_duration_msec', true)
            let rel_timestamp_response = data['rel_timestamp_response'];
            let reaction_time_msec = rel_timestamp_response - t0_choices_drawn;
            //console.log('reaction time', rel_timestamp_response, reaction_time_msec)

            if (reaction_time_msec < pre_choice_lockout_delay_duration_msec) {
                // Ignore clicks that occur before the pre-choice lockout delay
                //console.log('Ignored choice')
                return
            }

            // Log processed data
            data['reaction_time_msec'] = reaction_time_msec

            // CHeck whether mouse click occurred within a valid timeframe
            jsPsych.finishTrial(data)
        }


        let get_active_regions = function () {

            let stim_array_cur = jsPsych.getCurrentTrial().stim_array;
            let nway = jsPsych.timelineVariable('choice_image_urls', true).length;

            let active_regions = []
            for (let i_choice = 0; i_choice < nway; i_choice++) {
                let choice_object = stim_array_cur[i_choice];
                let choice_radius_px = choice_width_px / 2 || choice_object['radius'];

                let choice_startX_px = choice_object['startX'];
                let choice_startY_px = choice_object['startY'];
                active_regions.push(
                    {
                        'x': choice_startX_px,
                        'y': choice_startY_px,
                        'r': choice_radius_px,
                    }
                )
            }

            return active_regions
        }

        let choice_clicked_func = get_mouse_listener(
            get_active_regions,
            on_valid_response,
        )

        let screen_node = {
            type: jsPsychPsychophysics,
            stimuli: assemble_stimuli,
            background_color: function () {
                return MTS_TASK_GLOBALS.BACKGROUND_COLOR
            },
            response_type: 'mouse',
            response_ends_trial: false,
            response_start_time: jsPsych.timelineVariable('pre_choice_lockout_delay_duration_msec'),
            trial_duration: function () {
                let stimulus_duration_msec = jsPsych.timelineVariable('stimulus_duration_msec');
                let post_stimulus_delay_msec = jsPsych.timelineVariable('post_stimulus_delay_duration_msec');
                let pre_choice_lockout_delay_duration_msec = jsPsych.timelineVariable('pre_choice_lockout_delay_duration_msec');
                let choice_duration_msec = jsPsych.timelineVariable('choice_duration_msec') || undefined;
                let max_trial_duration = stimulus_duration_msec + post_stimulus_delay_msec + pre_choice_lockout_delay_duration_msec + choice_duration_msec || undefined;
                return max_trial_duration
            },
            canvas_width: function () {
                return MTS_TASK_GLOBALS.get_canvas_width_pixels();
            },
            canvas_height: function () {
                return MTS_TASK_GLOBALS.get_canvas_height_pixels();
            },
            canvas_offsetX: 0,
            canvas_offsetY: 0,
            clear_canvas: true,
            remain_canvas: false,
            show_start_time: 0,
            show_end_time: undefined,
            mouse_down_func: choice_clicked_func,
            on_start: function (trial) {
                let stimulus_duration_msec = jsPsych.timelineVariable('stimulus_duration_msec', true);
                let post_stimulus_delay_msec = jsPsych.timelineVariable('post_stimulus_delay_duration_msec');
                let pre_choice_lockout_delay_duration_msec = jsPsych.timelineVariable('pre_choice_lockout_delay_duration_msec');

                let timeout_msec = stimulus_duration_msec + post_stimulus_delay_msec + pre_choice_lockout_delay_duration_msec || 200;
                timeout_msec = timeout_msec + 100;
                setTimeout(
                    () => {
                        document.body.style.cursor = 'auto'
                    }, timeout_msec
                );
            },
            on_finish: function (data) {
                let rel_timestamp_response = performance.now()
                let reaction_time_msec = rel_timestamp_response - t0_choices_drawn;

                // Log processed data
                stimulus_drawn = false;
                choices_drawn = false;
                // Evaluate choice if there is a correct choice
                let i_correct_choice = jsPsych.timelineVariable('i_correct_choice');
                let no_correct_choice_exists = i_correct_choice === null || typeof i_correct_choice === 'undefined';
                let correct_choice_exists = !no_correct_choice_exists;
                let gt;
                if (correct_choice_exists === false) {
                    gt = null;
                    //console.log('No correct choice', i_correct_choice)
                } else {
                    if (!data['choices_made'] || i_correct_choice >= data['choices_made'].length) {
                        console.log('choices_made is null, or undefined, or i_correct_choice is out of bounds.')
                        gt = null
                    } else {
                        gt = data['choices_made'][i_correct_choice] === true ? 1 : 0;
                        //console.log('Correct: ', gt)
                    }
                }

                let trial_outcome = {}
                let tstart = performance.timing.navigationStart;
                let tstart_trial = data['time_elapsed'] // Round to the millisecond
                trial_outcome['timestamp_start'] = (tstart + tstart_trial) / 1000 // Unix timestamp
                trial_outcome['choices_made'] = data['choices_made']
                // Get the index of the first positive choice
                trial_outcome['i_choice'] = data['i_choice'];
                trial_outcome['i_correct_choice'] = i_correct_choice;
                trial_outcome['rel_timestamp_response'] = rel_timestamp_response
                trial_outcome['perf'] = gt; // Needed for feedback screen
                trial_outcome['reaction_time_msec'] = reaction_time_msec;

                delete data['choices_made']
                delete data['rel_timestamp_response']
                delete data['reaction_time_msec']
                delete data['i_choice']

                trial_outcome['trial_type'] = jsPsych.timelineVariable('trial_type', true)

                trial_outcome['block'] = jsPsych.timelineVariable('block', true)
                trial_outcome['stimulus_image_url'] = jsPsych.timelineVariable('stimulus_image_url', true)
                trial_outcome['class'] = jsPsych.timelineVariable('class', true)
                trial_outcome['choice_names'] = jsPsych.timelineVariable('choice_names', true)
                trial_outcome['choice_image_urls'] = jsPsych.timelineVariable('choice_image_urls', true)
                trial_outcome['query_string'] = jsPsych.timelineVariable('query_string', true)
                trial_outcome['stimulus_duration_msec'] = jsPsych.timelineVariable('stimulus_duration_msec', true)
                trial_outcome['post_stimulus_delay_duration_msec'] = jsPsych.timelineVariable('post_stimulus_delay_duration_msec', true)
                trial_outcome['pre_choice_lockout_delay_duration_msec'] = jsPsych.timelineVariable('pre_choice_lockout_delay_duration_msec', true)
                trial_outcome['choice_duration_msec'] = jsPsych.timelineVariable('choice_duration_msec', true)
                trial_outcome['keep_stimulus_on'] = jsPsych.timelineVariable('keep_stimulus_on', true)
                trial_outcome['trial_number'] = MTS_TASK_GLOBALS.TRIALS_COMPLETED;
                trial_outcome['stimulus_width_px'] = stimulus_width_px
                trial_outcome['choice_width_px'] = choice_width_px
                trial_outcome['monitor_width_px'] = trial_monitor_width_px;
                trial_outcome['monitor_height_px'] = trial_monitor_height_px;
                
                trial_outcome['stimulus_name'] = trial_outcome['choice_names'][trial_outcome['i_correct_choice']]  
                trial_outcome['choice_name'] = trial_outcome['choice_names'][trial_outcome['i_choice']]

                trial_outcome['condition_idx'] = jsPsych.timelineVariable('condition_idx', true)

                let bonus_usd_if_correct = jsPsych.timelineVariable('bonus_usd_if_correct', true) || 0;
                trial_outcome['bonus_usd_if_correct'] = bonus_usd_if_correct;

                data['trial_outcome'] = trial_outcome
                // console.log('Trial outcome', trial_outcome)
                MTS_TASK_GLOBALS.TRIALS_COMPLETED += 1;
                if (correct_choice_exists === true) {
                    if (gt === 1) {
                        if (trial_outcome['trial_type'] != "repeat_stimulus" && trial_outcome['trial_type'] != "calibration") {
                            MTS_TASK_GLOBALS.BONUS_USD_EARNED += bonus_usd_if_correct;
                        }
                    }
                }
            }
        }

        return screen_node
    }


    static get_intertrial_node() {

        return MTS_Trial_Nodes.get_blank_screen_node(
            () => {
                return MTS_TASK_GLOBALS.BACKGROUND_COLOR
            },
            () => {
                return MTS_TASK_GLOBALS.get_canvas_width_pixels()
            },
            () => {
                return MTS_TASK_GLOBALS.get_canvas_height_pixels()
            },
            jsPsych.timelineVariable('intertrial_delay_duration_msec'),
        )
    }
}

function get_nway_afc_trials(trial_sequence, session_settings) {

    MTS_TASK_GLOBALS.NTRIALS = trial_sequence.length;
    let instructions_node = get_instructions_node(session_settings['instructions_html'])

    let mts_nodes = [];
    let image_urls_to_load = [];

    // Sample random integer
    const refresh_param = Math.random().toString()//
    function refresh_url(url_string){
        // Encourage browser to refresh image
        let url = new URL(url_string);
        url.searchParams.set('x', refresh_param);
        let url_string_refreshed = url.toString()
        return url_string_refreshed
    }

    let show_test_instructions = false

    for (let i = 0; i < trial_sequence.length; i++) {

        let timeline_cur = MTS_Trial_Nodes.get_timeline();
        let timeline_variables_cur = trial_sequence[i];

        // If we're transitioning to the test block, show test instructions
        if (timeline_variables_cur['show_test_instructions'] && !show_test_instructions) {
            let test_instructions_node = get_instructions_node([session_settings['test_instructions_html']])
            mts_nodes.push(test_instructions_node)
        }
        show_test_instructions = timeline_variables_cur['show_test_instructions']

        let stimulus_image_url = refresh_url(timeline_variables_cur['stimulus_image_url']);
        let choice_image_urls = timeline_variables_cur['choice_image_urls'].map(refresh_url);
        let feedback_correct_url = refresh_url(timeline_variables_cur['feedback_correct_url']);
        let feedback_incorrect_url = refresh_url(timeline_variables_cur['feedback_incorrect_url']);

        timeline_variables_cur['stimulus_image_url'] = stimulus_image_url;
        timeline_variables_cur['choice_image_urls'] = choice_image_urls;
        timeline_variables_cur['feedback_correct_url'] = feedback_correct_url;
        timeline_variables_cur['feedback_incorrect_url'] = feedback_incorrect_url;

        image_urls_to_load.push(stimulus_image_url);
        image_urls_to_load.push(feedback_correct_url);
        image_urls_to_load.push(feedback_incorrect_url);
        image_urls_to_load = image_urls_to_load.concat(choice_image_urls);

        mts_nodes.push({
                timeline: timeline_cur,
                timeline_variables: [timeline_variables_cur],
            }
        )
    }

    // The following function checks the image URLs for testing purposes, to be run ONLY if outside mechanical turk. 
    function preloadImagesAndIdentifyErrors(imageUrls, onComplete) {
        let loadedCount = 0;
        const errors = [];
        imageUrls.forEach((url) => {
            const img = new Image();
            img.onload = () => {
                loadedCount++;
                if (loadedCount === imageUrls.length) {
                    onComplete(errors);
                }
            };
            img.onerror = () => {
                console.error('Failed to load:', url);
                errors.push(url);
                loadedCount++;
                if (loadedCount === imageUrls.length) {
                    onComplete(errors);
                }
            };
            img.src = url;
        });
    }

    if (jsPsych.turk.turkInfo().outsideTurk) {
        preloadImagesAndIdentifyErrors(image_urls_to_load, (errors) => {
            if (errors.length > 0) {
                console.log('Failed URLs:', errors);
            } else {
                console.log('All images loaded successfully.');
            }
        });
    }

    let task_preload = {
        type: jsPsychPreload,
        auto_preload: false,
        show_progress_bar: true,
        message: 'Loading images...',
        images: image_urls_to_load,
        on_start: function () {
            document.body.style.backgroundColor = '#7F7F7F';
        },
        on_finish: function () {
            console.log('Done preloading MTS assets.')
            jsPsych.setProgressBar(0.005);
        }
    }

    // Setup fullscreen

    let fullscreen_node = {
        timeline: [
            {
                type: jsPsychFullscreen,
            }
        ],
        conditional_function: function () {
            let run = session_settings['force_fullscreen'] === true
            return run;
        },
    }
    // console.log('MTS nodes:', mts_nodes)
    let monitor_calibration_node = {
        timeline: [
            {
                type: jsPsychMyVirtualChinrest,
                credit_card_reps: 1,
                blindspot_reps: 2,
                credit_card_image_path: 'https://miljspsych.s3.amazonaws.com/resources/assets/images/card.png',
                credit_card_init_size: function () {
                    let loaded_cookie = CookieUtils.getCookie('external-my-virtual-chinrest')
                    let initial_credit_card_size_pixels = 400; // Default

                    if (loaded_cookie.length > 0) {
                        loaded_cookie = JSON.parse(loaded_cookie)
                        console.log('Loaded cookie:', loaded_cookie)
                        let final_item_width_px = loaded_cookie['outputs']['average_reported_item_width_px']
                        if (typeof final_item_width_px === 'number') {
                            initial_credit_card_size_pixels = Math.min(1000, Math.max(40, final_item_width_px))
                        }
                    }
                    return initial_credit_card_size_pixels
                },
                on_finish: function (data) {
                    console.log('Monitor calibration done. Result:', data)
                    _store_jspsych_cookie(data)
                    console.log(data)
                    let viewing_distance_px = data['outputs']['viewing_distance_px']
                    MTS_TASK_GLOBALS.calibrate_viewing_distance(viewing_distance_px);
                }
            },
        ],
        conditional_function: function () {
            let run = session_settings['calibrate_monitor'] === true
            return run;
        },
    }
    let timeline = [fullscreen_node, instructions_node, task_preload, monitor_calibration_node].concat(mts_nodes)
    let finish_node = {
        type: jsPsychHtmlButtonResponse,
        choices: ['Press to continue'],
        trial_duration: 10000,
        stimulus: function () {
            let bonus_usd_earned = MTS_TASK_GLOBALS.BONUS_USD_EARNED
            let bonus_safety = 1;

            let qualification_type_ids = [done_qualification_type_id]
            assign_quals_lambda_wrapper(qualification_type_ids, SANDBOX);

            if (bonus_usd_earned >= 0.20) {
                MTS_TASK_GLOBALS.BONUS_USD_EARNED = 5.00
                return 'Thank you for your work. Your accuracy was ' + ((bonus_usd_earned / 0.40)*100).toFixed(0).toString() + '%. You earned a bonus of $5.00!'
            } else {
                MTS_TASK_GLOBALS.BONUS_USD_EARNED = 0
                return 'Thank you for your work. Your accuracy was ' + ((bonus_usd_earned / 0.40)*100).toFixed(0).toString() + '%. Because more than 50% was required for the bonus, you will not receive a bonus this time.'
            }
        },
        on_finish: function(data) {
            data.response = MTS_TASK_GLOBALS.BONUS_USD_EARNED;
        }
    }

    timeline.push(finish_node)
    let block_timeline = {
        'timeline': timeline,
    }
    return block_timeline
}
</script>

<script>
    function session_metadata_lambda(experiment_name, experiment_number, aws_prefix, api_gateway_url) {
        const turkInfo = jsPsych.turk.turkInfo();
        return new Promise((resolve, reject) => {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        var response = JSON.parse(xhr.responseText);
                        resolve(response);
                    } else {
                        reject('Request failed with status: ' + xhr.status);
                    }
                }
            };

            xhr.open("POST", api_gateway_url, true);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.setRequestHeader("Accept", "application/json");
            
            if (turkInfo.outsideTurk === false && turkInfo.previewMode === false) {
                xhr.send(JSON.stringify({
                    experiment_name: experiment_name,
                    experiment_number: experiment_number,
                    aws_prefix: aws_prefix,
                    worker_id: turkInfo.workerId,
                    hit_id: turkInfo.hitId,
                    assignment_id: turkInfo.assignmentId
                }));
            }
            else {
                xhr.send(JSON.stringify({
                    experiment_name: experiment_name,
                    experiment_number: experiment_number,
                    aws_prefix: aws_prefix,
                })); 
            }
        });
    }

    function assign_quals_lambda(qualification_type_ids, sandbox) {
        const turkInfo = jsPsych.turk.turkInfo();
        return new Promise((resolve, reject) => {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        var response = JSON.parse(xhr.responseText);
                        resolve(response);
                    } else {
                        reject('Request failed with status: ' + xhr.status);
                    }
                }
            };

            xhr.open("POST", ASSIGN_QUALS_LAMBDA_API_GATEWAY_URL, true);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.setRequestHeader("Accept", "application/json");
            
            if (turkInfo.outsideTurk === false && turkInfo.previewMode === false) {
                xhr.send(JSON.stringify({
                    worker_id: turkInfo.workerId,
                    qualification_type_ids: qualification_type_ids,
                    score: parseInt(MTS_TASK_GLOBALS.BONUS_USD_EARNED*100),
                    sandbox: sandbox
                }));
            }
        });
    }

    async function assign_quals_lambda_wrapper(qualification_type_ids, sandbox) {
        console.log("assigning quals")
        qual_lambda_response = await assign_quals_lambda(qualification_type_ids, SANDBOX);
        console.log(qual_lambda_response)
    }

    function load_script(url) {
        return new Promise((resolve, reject) => {
            var script = document.createElement('script');
            script.src = url;
            script.onload = () => resolve(script);
            script.onerror = () => reject(new Error(`Script load error for ${url}`));
            document.head.appendChild(script);
        });
    }
</script>

<script>
    async function run_experiment(experiment_name, experiment_number, aws_prefix) {
        try {
            const turkInfo = jsPsych.turk.turkInfo();
            let user_in_preview_mode = turkInfo.previewMode;
            
            bucket_url = 'https://' + `${aws_prefix}-${experiment_name.replace(/_/g, "-").toLowerCase()}-${experiment_number}` + '.s3.amazonaws.com';
            
            let trialset_id

            // Load API gateway URL from .js stored on s3
            await load_script(bucket_url + "/aws_constants.js"); // session_metadata_api_url defined inside

            // Load a real experiment session if inside turk. Otherwise, just load trialset 0 for testing purposes. 
            if (turkInfo.outsideTurk === false && turkInfo.previewMode === false) {
                // Wait for session_metadata_lambda to complete and get the response
                const response = await session_metadata_lambda(experiment_name, experiment_number, aws_prefix, session_metadata_api_url);
                trialset_id = response.trialset_id;
            }
            else {
                trialset_id = 0;
            }

            // Load the trialset as a js file in s3
            let trialset_url = new URL(bucket_url + '/trialsets/' + `${experiment_name}_${experiment_number}_trials_${trialset_id}.js`)
            trialset_url.searchParams.set('x', Math.random().toString()) // Encourage browser to refresh
            trialset_url_string = trialset_url.toString()
            await load_script(trialset_url_string);

            let experiment_timeline = get_nway_afc_trials(trial_variables, session_settings);

            jsPsych.run([
                preview_gate,
                browser_check_node,
                global_preload,
                experiment_timeline,
                get_turk_submission_node(trialset_id)
            ],)

        } catch (error) {
            console.error('Error:', error);
        }
    }
</script>

<script>

    //console.log('URL: ', window.location.href)

    let jsPsych = initJsPsych(
        {
            show_progress_bar: true,
            auto_update_progress_bar: false,
            message_progress_bar: 'Progress',
        }
    );

    let session_settings = {
    "instructions_html": [
        "<ul> <li>Thank you for accepting this HIT!</li> <li>This task involves learning to distinguish four different skin conditions that look very similar to each other.</li> <li> Your participation will help us find better ways to teach medical students to identify and diagnose diseases more accurately. </li> <li> <b>WARNING:</b> images in this task show various skin conditions on different parts of the body. Some images may be graphic or unsettling.</li>   <li>Some trials may be very hard. We cannot guarantee that it is possible to choose accurately in all cases.</li> <li>We reserve the right to end the experiment at any time.</li> <li>If you encounter a bug (e.g., the task freezing), please contact us and let us know. You will be compensated for your time.</li> <li>If you wish, you may view our full consent form document <a href=\"https://morgan-study-misc.s3.amazonaws.com/Consent_Form_19Nov2019.pdf\">here.</a></li> <li>By clicking \"Continue\" on the next page, you voluntarily consent to be a participant in our experiment and agree to all of the rules above.</li> </ul>",
        "<ul> <b>INSTRUCTIONS</b> <li>Click one of the round buttons to make a choice on each image.</li> <li> Please try your best to learn by trial and error.</li> <li>You must make each choice within <b>10 seconds</b></li> <li>After a training phase with feedback on each choice, there is a test phase with no feedback.</li> <li> <b> If your accuracy in the test phase is 50% or higher, you will <text style=\"color:green; font-style:oblique\">earn a bonus of $5.00</text> </b> </li> </ul>"
    ],
    "test_instructions_html": "\n <ul>\n    <li>Thank you for completing the training phase of the experiment!</li>\n       <li>Press \"Continue\" to begin the test phase.</li>\n  <li>During the test, you will <b>not</b> receive feedback, but <text style=\"color:green; font-style:oblique\">accuracy above 50% will result in a bonus of $5.00.</text></li>\n      </ul>",
    "calibrate_monitor": false,
    "force_fullscreen": false
    };


    let browser_check_node = get_browser_check_node();

    // Run the timeline
    let preview_gate = {
        timeline: [{
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<h1 style="color:red">PREVIEW MODE</h1> Please accept the HIT to continue.',
            choices: [' '],
            on_start: function () {
                console.log('At preview gate.')
            },
        }],
        conditional_function: function () {
            const turkInfo = jsPsych.turk.turkInfo();
            let user_in_preview_mode = turkInfo.previewMode;
            return user_in_preview_mode;
        },
    };

    // Global preload
    let global_preload = {
        type: jsPsychPreload,
        auto_preload: true,
        show_progress_bar: true,
    };

    run_experiment(experiment_name, experiment_number, aws_prefix)
</script>


</html>

